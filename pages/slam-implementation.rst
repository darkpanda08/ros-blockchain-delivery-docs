SLAM Implementation
#####################

In this section, we will look at how we implemented the SLAM in our project.

Mapping
********

Gmapping, which was used in this project, is a laser-based SLAM (Simultaneous Localization and Mapping) algorithm that builds a 2d map.
It uses laser scan data and odometry data from the robot to feed a highly efficient Rao-Blackwellized particle filer to learn grid maps from laser range data.
The laser scan is generated by taking the point cloud from the 3D sensor and grabbing points from an “eye-level” prespective of the robot. It does not use any RGB data, or any full depth data.

The package contains a node called ``slam_gmapping``. This node will generate the 2D map of our environment and we can then save the map for further use.

.. seealso::

    More information can be found in `ROS Wiki Gmapping <http://wiki.ros.org/gmapping>`_

Localization
*************

For localizing the robot in our environmnet, AMCL was used which is a probabilistic localization system for a robot moving in 2D. 
It implements the ``Adaptive Monte Carlo Localization`` approach which uses a particle filter to track the pose of a robot against a known map.

Each sample stores a position and orientation data representing the robot’s pose. Particles are all sampled randomly initially. When the robot moves, particles are resampled based on their current state as well as robot’s action using recursive Bayesian estimation.

.. seealso::

    More information can be found in `ROS Wiki AMCL <http://wiki.ros.org/amcl>`_

Navigation
***********

Costmaps
=========

Cost map is a grid in which every cell gets assigned a value (cost) determining distance to obstacle, where higher value means closer distance. Using this map, the robot plans the path in such a way that it avoids obtsacles by creating a trajectory with lowest cost.
Costmap is composed of static map layer, obstacle map layer and inflation layer. Static map layer directly interprets the given static SLAM map provided to the navigation stack. 
Obstacle map layer includes 2D obstacles and 3D obstacles (voxel layer). Inflation layer is where obstacles are inflated to calculate cost for each 2D costmap cell.

There are 2 costmaps, one for local planner which determines obtsacles near the robot and the other one for global planner to plan a global path from the start point to the goal with keeping the obstacles in mind.
Global costmap is generated by inflating the obstacles on the map provided to the navigation stack. Local costmap is generated by inflating obstacles detected by the robot’s sensors in real time.

Costmap parameters tuning is essential for the success of teh local planners.

Common Costmap Parameters
--------------------------

- obstacle_range
- raytrace_range
- inflation_radius
- observation_sources
- footprint

Global Costmap Parameters
--------------------------

- transform_tolerance
- robot_base_frame
- global_frame
- update_frequency
- publish_frequency

Local Planner
==============

Local planner is used to find a suitable local plan at every instance. Using a map, the planner creates a kinematic trajectory for the robot to get from a start to a goal location. Along the way, the planner creates, at least locally around the robot, a value function, represented as a grid map.
This value function encodes the costs of traversing through the grid cells. The controller's job is to use this value function to determine dx, dy, dtheta velocities to send to the robot.

Local planners that adhere to nav core::BaseLocalPlanner interface are ``dwa local planner``, ``eband local planner`` and ``teb local planner``. They use different al-
gorithms to generate velocity commands.

Global Planner
===============

The purpose of global path planner is to plan the shortest path which avoids all the obstacle from the start point to the goal point. There are a lot of various path planers used such as Djiktstras, D star, potential field.
A star is a grid-based algorithm. It uses the global costmap provided to find the fastest path to the goal point without hitting any obstacle.

In our Implementation, we have used the global planner for the robot to plan the path till the goal location.

There are three global planners that adhere to ``nav core::BaseGlobal Planner interface:`` ``carrot planner``, ``navfn`` and ``global planner``.

carrot_planner
---------------

It checks if the given goal is an obstacle, and if so it picks an alternative goal close to the original one, by moving back along the vector between the robot and the goal point. Eventually it passes this valid goal as a plan to the local planner or controller. 
Therefore, this planner does not do any global path planning. It is helpful if we require our robot to move close to the given goal even if the goal is unreachable. In complicated indoor environments, this planner is not very practical.

.. seealso::

    More information can be found in `ROS Wiki Carrot Planner <http://wiki.ros.org/carrot_planner>`_

navfn and global planner
-------------------------

``navfn`` uses Dijkstra’s algorithm to find a global path with minimum cost between start point and end point. ``global planner`` is built as a more flexible replacement of navfn with more options. 
These options include (1) support for A∗, (2) toggling quadratic approximation, (3) toggling grid path.

.. seealso::

    More information regarding ``navfn`` can be found in `ROS Wiki navfn <http://wiki.ros.org/navfn>`_ and for ``global planner`` can be found in `ROS Wiki Global Planner <http://wiki.ros.org/global_planner>`_

Move Base
----------

The ``move_base`` node provides a ROS interface for configuring, running, and interacting with the navigation stack on a robot. The ``move_base`` package provides an implementation of an action that, given a goal in the world, will attempt to reach it with a mobile base.
The ``move_base`` node links together a global and local planner to accomplish its global navigation task.

This node provides an implementation of the ``SimpleActionServer``, that takes in goals containing ``geometry_msgs/PoseStamped`` messages. We can communicate with the ``move_base`` node over ROS directly, but the recommended way to send goals to ``move_base`` if we are tracking their status is by using the SimpleActionClient.

.. seealso::

    More information can be found in `ROS Wiki Move Base <http://wiki.ros.org/move_base>`_